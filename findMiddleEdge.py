#!/usr/bin/env python
'''
Input: Two amino acid strings.
Output: A middle edge in the alignment graph in the form "(i, j) (k, l)", where (i, j) connects to (k, l).
To compute scores, use the BLOSUM62 scoring matrix and a (linear) indel penalty equal to 5.
'''


def alignBacktrack(v, w, n, m, matrix, sigma):
	'''
	v, w are two str containing separated characters
	dimension of s is (|v| + 1) * (|w| + 1)
	'''
	backtrack = []
	s = []
	for i in range(n + 1):
		s.append([0])
		backtrack.append([' '])
	'''
	s[0][0] has already been given a value, so next we begin from s[0][1]
	'''
	for i in range(n + 1):
		for j in range(m):
			backtrack[i].append(' ')
			s[i].append(0)
	# initialize
	for i in range(n):
		s[i + 1][0] = s[i][0] - sigma
	for j in range(m):
		s[0][j + 1] = s[0][j] - sigma
	s[0][0] = 0
	for i in range(n):
		for j in range(m):
			s[i + 1][j + 1] = max((s[i][j + 1] - sigma), (s[i + 1][j] - sigma), (s[i][j] + matrix[v[i]][w[j]]))
	middle = 0
	maxedge = s[0][m - 1]
	for i in range(n):
		if s[i][m - 1] > maxedge:
			maxedge = s[i][m - 1]
			middle = i
	return [[middle, m - 1], [middle + 1, m]]


def loadMatrix(filename):
	score = {}
	keys = []
	with open(filename, 'r') as f:
		for line in f:
			line = line.rstrip()
			if line[0] == ' ':
				# the first line
				line = line.split('  ')
				keys = line[1:]
				keys[0] = 'A'
				# print keys
			else:
				score[line[0]] = {}
				line = line.split('  ')
				# first element is the name of this row
				rowName = line[0]
				line = line[1:]
				for i in range(len(keys)):
					score[rowName][keys[i]] = int(line[i])
	return score


def main():
	matrix = loadMatrix('BLOSUM62.txt')
	sigma = 5
	v = 'LDVPYHKFDKAWTGYGWIESMDCSSANYLHWHIQQWQAPEHKTTQWVWCYEQPGNPIKKVWPYFFVAGLFRSVPLTGCYMSVFPCASNDCPADRPSGRWCMYNPIGDLEAYQNWCPMMMCSENCCWPRTHQYTQDNTQIVYYIGLPRDIPPCGQYCGHMYYWYYDHVNKNKSFKVCRGTWFEVECHKGCTKQIYMAGSQQIHKADYGVMALTHTKNYIEGNKSGWVFRICWLTRYNRTMEISWFFWCVGLFPFAKIYFNNFMSGWGIKYYTLKGFYNDPDKTTEAFIGTSFISWSKEDAYQYHREYLNYQFGTWEKQPVSECERMPHVYRCPWFKNEGRFNPGFSHQSPLCYIEMIAPCAHYNWIFGANLAFVSYKRETCPAKPIFGNDSCGWPWFEGCEYAHTYTWHGYFTFMMHRINYLMHKQWAHASTMAAIGCVMKMEAPYHCMNWAGKEPMALGIKEEYTLDEAYRNVFFEAPAPTSFQTVHIQGRWSIWMSELQTWVWTPPFEVCFNDCFIADFTFYRRVRCKRNFVWSSANMTFWTLTNPPALIMFMYPKEPWHMSEKCKMCAIPESISGCRATCLKFTLYAEMSPMDQCDMKYHYVVYIDRNQGEAIYICNCYIPWWCRGCSQMGYDEGYYNNQRFRMKPLAYFVEIWQKMIRLLYLKVNYEQITKMLFQMVEFTKEQANCHGCNSWEHGKQDKSYSAATSNGPQPCQHFFNDQDELMCAREYYMEYIEGDSVTMHFTVRDHGHEVMKWETMEREGVECNSMAWSPRHHNVWAYVSTAWFRMGLLASCMQESYIHHSVWPSPLHNAGAHGYVTNHPFNVFTNVIVWANYHEHQFKNDEGACVETEMMGLQSIDFTMAGQSCKCKNPIEIYGVVRSPWEKGFQHHLELILEYGGLLTDDCNHEYDYNAELSQFHWFYPQYYIAADVKIWPNLYTNMWGNVKRQTTRSKPESFMLMNLLQTHEVMIAMRNIFLMIDRKVDEYEVYRQCKFKNKKCKSNIRKRQVSVIGDHVIWEMNLARDSPDVQKCRN'
	w = 'IPDDDETIYQRTPWVPVTTKRDQLESEGWPLEAMNGQFEWDVQPCLKLYTWSDIKRKCVNSYPGDQCKCEATEKTIGMYDNAMVPFTDQQWYKDGQYLYMCLGCFNHCEWNQQMFFKLRAYITKAPPEGEVTVCENYNWEMGDLLVCHRARLGCNRNGWAAWIRNSITQINRRNKFKMTEEWQGNRMPVVLKGRVKQLRMVKQDFIRPCYLSPDDKSLQHETGNSIDPSAKHRAAAVFHQCRLPKRNTWTNAKSLRDAIGAIYYCYLKQNVDRFHAQLHSGPNYNPMSCKMHNISYTVEAENVNYHNVKKIFANTFWRYPIFWAVNNPSQSLDMVDKIHADAYDTLDWQYYMPVWPFQQNHNPWSVLMCLACWMRPWNPSYHSNELPADLTQAWCKRIVPKPISSEHHHVGAVSHVEYEFSPCEPQKIMFHHPRCVMDCEHIYGPTQRAHAGKEPMALGIKEEYTEAPAPTSFQTVHIQGRWSIPMSELQTWVWFPFVYFNDCFIADFTFYRSVRCKRNFDFTFSCFEGYHTVRLTNALIFWHIKLMFHETHCAIPSSIAGCRAFCLKFPDLYMYETTGKNRQDSHRRHMDCFKFIPFYSNWMMHSLQVNLHKHQWPQYVSIDNGRTFAKHKYHHYWWMCWTVWAYIRMVPLHTQFWVHYACIHYQKYCAPKLMFSSEWDTGFCYTSNKNTHPHGMRELHDLASGLPQIRGSQGKVRVKCRMQTDKNFIYKYLTEVPGVGQMHKPRAGQRMRYMYMLEWCVWETHYEFLACSFGNIRHLLGYTYKCEKMMFMCITVGVIDPTKPMMAWTPPHDWYQEGPPAVSMHYCSCKSQPSTEDCSNWDVAVPYYAYALPTLEKIYEDCHVERVCWNQPEHDPTYHYPTHHGIHKAVIQFGASQVYEDVMYSDANTLQNQGWWIMDSPWRIIRLCRVPSLLVQLGDWNNQIKNSIWFPCRGVECFNHEKAFVDDNIAEISTNRKRPDNVMVWIWPPERLSGSIDGIWWVHFNPFDWDKTATDNLYQ'
	n = len(v)
	m = len(w)
	backtrack = alignBacktrack(v, w, n, m / 2 + 1, matrix, sigma)
	print backtrack


if __name__ == '__main__':
	main()
